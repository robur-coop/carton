<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Carton (carton.Carton)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.4"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../index.html">carton</a> &#x00BB; Carton</nav><header class="odoc-preamble"><h1>Module <code><span>Carton</span></code></h1><p>Decoder of a PACK file.</p><p>This module implements what is needed to decode a PACKv2 file. It is independent of any scheduler. For cooperation issues, we recommend that you refer to the documentation for Cachet, the library used to read a PACK file. More specifically, Carton is based on the use of <code>Unix.map_file</code> (or equivalent). Access to a block-device or file does <b>not</b> block, but it can take time. In short, the cooperation points have to be added by the user. As an <i>atomic</i> operation such as reading the PACK file (via <code>Unix.map_file</code>) cannot be interleaved by cooperation points.</p><p>The module is divided into 3 parts:</p><ul><li>the first consists of a <a href="First_pass/index.html"><code>First_pass</code></a> module for analysing a PACK stream. This is useful when the PACK file is transmitted over the network. In such a case, this analysis can be applied.</li><li>the second consists of extracting objects from a PACK file, the contents of which can be made available via a <code>Unix.map_file</code> function.</li><li>the third consists of a few types that may be useful for checking a PACK file. Documentation is provided to explain how to use these types.</li></ul></header><nav class="odoc-toc"><ul><li><a href="#extracting-objects-from-a-pack-file.">Extracting objects from a PACK file.</a><ul><li><a href="#path">Path of object.</a></li></ul></li></ul></nav><div class="odoc-content"><div class="odoc-spec"><div class="spec module anchored" id="module-H"><a href="#module-H" class="anchor"></a><code><span><span class="keyword">module</span> H</span><span> = <a href="../H/index.html">H</a></span></code></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Zh"><a href="#module-Zh" class="anchor"></a><code><span><span class="keyword">module</span> Zh</span><span> = <a href="../Zh/index.html">Zh</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-bigstring_of_string"><a href="#val-bigstring_of_string" class="anchor"></a><code><span><span class="keyword">val</span> bigstring_of_string : <span>string <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Cachet</span>.bigstring</span></code></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Kind"><a href="#module-Kind" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Kind/index.html">Kind</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>A PACK file contains several types of object. According to Git, it contains commits (<code>`A</code>), trees (<code>`B</code>), blobs (<code>`C</code>) and tags (<code>`D</code>). Carton is far enough removed from Git to abstract itself from the actual type of these objects.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Size"><a href="#module-Size" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Size/index.html">Size</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>The size is a non-negative number which corresponds to the size of a <a href="Blob/index.html"><code>Blob</code></a> in memory in bytes.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Uid"><a href="#module-Uid" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Uid/index.html">Uid</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>An object can be identified by a unique identifier that needs to be calculated by an algorithm such as a hash algorithm. These identifiers can be used to refer to a possible source when we have a <a href="First_pass/index.html#type-kind.Ref"><code>First_pass.kind.Ref</code></a> entry.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-First_pass"><a href="#module-First_pass" class="anchor"></a><code><span><span class="keyword">module</span> <a href="First_pass/index.html">First_pass</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><h2 id="extracting-objects-from-a-pack-file."><a href="#extracting-objects-from-a-pack-file." class="anchor"></a>Extracting objects from a PACK file.</h2><p>Once it is possible to use <code>Unix.map_file</code> (or equivalent) on a PACK file (i.e. once it is available in a file system), it is possible to extract all the objects in this PACK file.</p><p>Extraction consists of either:</p><ul><li>decompressing a <a href="First_pass/index.html#type-kind.Base"><code>First_pass.kind.Base</code></a> entry</li><li>decompressing a <i>patch</i> and reconstructing the object from a source</li></ul><p>In both cases, we use <code>bigstring</code>s. The advantage of the latter is that they are not relocated by the OCaml GC. The disadvantage is their allocation (via <code>malloc()</code>), which can take a long time.</p><p>Memory usage is also a disadvantage. If an object is 1 Go in size, we are obliged to allocate a <code>bigstring</code> of 1 Go (or more). It is not possible to <i>stream-out</i> all objects - only <a href="First_pass/index.html#type-kind.Base"><code>First_pass.kind.Base</code></a> objects can be streamed-out.</p><p>To limit the use of <code>bigstring</code>s, there are various functions that let you know in advance:</p><ul><li>the true size of the object requested</li><li>the size needed to store the requested object and all the objects needed to rebuild it if it is stored as a <i>patch</i></li><li>the list of objects that need to be rebuilt to construct the requested object</li></ul><p>As far as <i>patch</i> entries are concerned (<a href="First_pass/index.html#type-kind.Ofs"><code>First_pass.kind.Ofs</code></a> and <a href="First_pass/index.html#type-kind.Ref"><code>First_pass.kind.Ref</code></a>), their source can also be an object from a <i>patch</i> which itself requires an object from a <i>patch</i>. This is referred to as the <i>depth</i> of the object in the PACK file. The maximum depth is 50: in other words, it may be necessary to reconstruct 49 objects upstream in order to build the requested object.</p><p>The advantage is, of course, the compression ratio. In addition to compressing the entries with <code>zlib</code>, some objects are just patches compared to other objects. For example, if the PACK file contains a <i>blob</i> with content <code>A</code> and another <i>blob</i> with content <code>A+B</code>, the latter could be a patch containing only <code>+B</code> and requiring our first <i>blob</i> as a source.</p><p>For simple use, the user must first calculate the size of the buffers needed to store the object in memory. They then need to allocate a <a href="Blob/index.html"><code>Blob</code></a> to hold the object. Finally, the object can be reconstructed according to its position (<code>cursor</code>) in the PACK file or according to its unique identifier if the user has the IDX file that allows the position of the object in the PACK file to be associated with its identifier (see <a href="../Classeur/index.html"><code>Classeur</code></a>).</p><pre class="language-ocaml"><code>let t = Carton.make ~map ~z ~allocate ~ref_length in
let size = Carton.size_of_offset t ~cursor in
let blob = Carton.Blob.make ~size in
Carton.of_offset t blob ~cursor</code></pre><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> <span>'fd t</span></span></code></div><div class="spec-doc"><p>Type representing a PACK file and used to extract objects.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-make"><a href="#val-make" class="anchor"></a><code><span><span class="keyword">val</span> make : 
  <span><span class="optlabel">?pagesize</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?cachesize</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">map</span>:<span><span class="type-var">'fd</span> <span class="xref-unresolved">Cachet</span>.map</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'fd</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">z</span>:<span class="xref-unresolved">Zl</span>.bigstring <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">allocate</span>:<span>(<span>int <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Zl</span>.window)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">ref_length</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><a href="Uid/index.html#type-t">Uid.t</a> <span class="arrow">&#45;&gt;</span></span> int)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'fd</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>make ~map fd ~z ~allocate ~ref_length where</code> creates a representation of the PACK file whose read access is managed by the <code>map</code> function. A few arguments are required so that Carton does not allocate buffers arbitrarily but gives the user fine-grained control over its allocation policy (since it essentially involves allocating <code>bigstrings</code>).</p><ul><li>A temporary buffer <code>z</code> is required to store a <i>deflated</i> entry</li><li>an <code>allocate</code> function is required to get a <code>Zl.window</code> required to deflate entries</li><li>it is necessary to know the size <code>ref_length</code> of the unique identifiers that can be used to refer to patches. In the case of Git, this value is <code>20</code> (the size of a SHA1 hash)</li><li>lastly, a function <code>where</code> <b>may</b> be required to find out the position of an object according to its unique identifier (see <a href="../Classeur/index.html"><code>Classeur</code></a>).</li></ul><p><b>Note</b>: If <code>where</code> is proposed and exhaustive, the <code>*of_uid*</code> functions can be used.</p><p><code>make</code> calls <code>Cachet.make</code> with the <code>cachesize</code> and <code>pagesize</code> arguments. These must be multiples of 2. For more details about these arguments and <code>map</code>, please refer to the Cachet documentation.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-of_cache"><a href="#val-of_cache" class="anchor"></a><code><span><span class="keyword">val</span> of_cache : 
  <span><span><span class="type-var">'fd</span> <span class="xref-unresolved">Cachet</span>.t</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">z</span>:<span class="xref-unresolved">Zl</span>.bigstring <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">allocate</span>:<span>(<span>int <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Zl</span>.window)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">ref_length</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><a href="Uid/index.html#type-t">Uid.t</a> <span class="arrow">&#45;&gt;</span></span> int)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'fd</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>of_cache cache ~z ~allocate ~ref_length where</code> is equivalent to <a href="#val-make"><code>make</code></a> but uses the <code>cache</code> already available and initialised by the user.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-copy"><a href="#val-copy" class="anchor"></a><code><span><span class="keyword">val</span> copy : <span><span><span class="type-var">'fd</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'fd</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>copy t</code> makes a copy of the PACK file representation, which implies a new empty cache and a copy of the internal buffers. In this way, the result of this copy can be used <b>in parallel</b> safely, even if our first value <code>t</code> attempts to extract objects at the same time.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fd"><a href="#val-fd" class="anchor"></a><code><span><span class="keyword">val</span> fd : <span><span><span class="type-var">'fd</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'fd</span></span></code></div><div class="spec-doc"><p><code>fd t</code> returns the file-descriptor given by the user to make the representation of the PACK file <code>t</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-cache"><a href="#val-cache" class="anchor"></a><code><span><span class="keyword">val</span> cache : <span><span><span class="type-var">'fd</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'fd</span> <span class="xref-unresolved">Cachet</span>.t</span></span></code></div><div class="spec-doc"><p><code>cache t</code> returns the cache used to access pages in the PACK file.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-allocate"><a href="#val-allocate" class="anchor"></a><code><span><span class="keyword">val</span> allocate : <span><span><span class="type-var">'fd</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Zl</span>.window</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-tmp"><a href="#val-tmp" class="anchor"></a><code><span><span class="keyword">val</span> tmp : <span><span><span class="type-var">'fd</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">De</span>.bigstring</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-ref_length"><a href="#val-ref_length" class="anchor"></a><code><span><span class="keyword">val</span> ref_length : <span><span><span class="type-var">'fd</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> int</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-map"><a href="#val-map" class="anchor"></a><code><span><span class="keyword">val</span> map : <span><span><span class="type-var">'fd</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">cursor</span>:int <span class="arrow">&#45;&gt;</span></span> <span><span class="label">consumed</span>:int <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Cachet</span>.Bstr.t</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-with_index"><a href="#val-with_index" class="anchor"></a><code><span><span class="keyword">val</span> with_index : <span><span><span class="type-var">'fd</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><a href="Uid/index.html#type-t">Uid.t</a> <span class="arrow">&#45;&gt;</span></span> int)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'fd</span> <a href="#type-t">t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Blob"><a href="#module-Blob" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Blob/index.html">Blob</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>The <code>Blob</code> is a tuple of temporary buffers used to store an object that has been decompressed or reconstructed using a patch and a source.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Visited"><a href="#module-Visited" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Visited/index.html">Visited</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec exception anchored" id="exception-Cycle"><a href="#exception-Cycle" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Cycle</span></span></code></div></div><div class="odoc-spec"><div class="spec exception anchored" id="exception-Too_deep"><a href="#exception-Too_deep" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Too_deep</span></span></code></div></div><div class="odoc-spec"><div class="spec exception anchored" id="exception-Bad_type"><a href="#exception-Bad_type" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Bad_type</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-size_of_offset"><a href="#val-size_of_offset" class="anchor"></a><code><span><span class="keyword">val</span> size_of_offset : 
  <span><span><span class="type-var">'fd</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?visited</span>:<a href="Visited/index.html#type-t">Visited.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">cursor</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><a href="Size/index.html#type-t">Size.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="Size/index.html#type-t">Size.t</a></span></code></div><div class="spec-doc"><p><code>size_of_uid pack ?visited ~cursor size</code> returns the size of the buffers (see <a href="Blob/index.html"><code>Blob</code></a>s) required to extract the object located at <code>cursor</code> from the PACK file. This does <b>not</b> correspond to the size of the object.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-size_of_uid"><a href="#val-size_of_uid" class="anchor"></a><code><span><span class="keyword">val</span> size_of_uid : <span><span><span class="type-var">'fd</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="optlabel">?visited</span>:<a href="Visited/index.html#type-t">Visited.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">uid</span>:<a href="Uid/index.html#type-t">Uid.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="Size/index.html#type-t">Size.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="Size/index.html#type-t">Size.t</a></span></code></div><div class="spec-doc"><p><code>size_of_uid pack ?visited ~uid size</code> returns the size of the buffers (see <a href="Blob/index.html"><code>Blob</code></a>s) required to extract the object identified by <code>uid</code> from the PACK file. This does <b>not</b> correspond to the size of the object.</p><p>The given <code>pack</code> must be able to recognize the object's position based on its unique identifier. In other words, <code>pack</code> must be constructed with an exhaustive <code>where</code> function for all the identifiers in the PACK file.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-actual_size_of_offset"><a href="#val-actual_size_of_offset" class="anchor"></a><code><span><span class="keyword">val</span> actual_size_of_offset : <span><span><span class="type-var">'fd</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">cursor</span>:int <span class="arrow">&#45;&gt;</span></span> <a href="Size/index.html#type-t">Size.t</a></span></code></div><div class="spec-doc"><p><code>actual_size_of_offset pack ~cursor</code> returns the <b>true</b> size of the object located at cursor in the given <code>pack</code> PACK file.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Value"><a href="#module-Value" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Value/index.html">Value</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-of_offset"><a href="#val-of_offset" class="anchor"></a><code><span><span class="keyword">val</span> of_offset : <span><span><span class="type-var">'fd</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="Blob/index.html#type-t">Blob.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">cursor</span>:int <span class="arrow">&#45;&gt;</span></span> <a href="Value/index.html#type-t">Value.t</a></span></code></div><div class="spec-doc"><p><code>of_offset pack blob ~cursor</code> is the object at the offset <code>cursor</code> into the given <code>pack</code>.</p><p><b>Note</b>: This function does not allocate larges resources (or, at least, only the given <code>allocate</code> function to <a href="#type-t"><code>t</code></a> is able to allocate a large resource). <code>blob</code> (which should be created with the associated <a href="Size/index.html#type-t"><code>Size.t</code></a> given by <a href="#val-size_of_offset"><code>size_of_offset</code></a>) is enough to extract the object.</p><p><b>Note</b>: This function is <b>not</b> tail-recursive. In other words, it can discover, step by step, the patches needed to rebuild the object. Even though a well-formed PACK file should not contain objects deeper than <code>50</code>, if you want to rebuild an object and are sure that the function is tail-recursive, you need to calculate its <a href="Path/index.html#type-t"><code>Path.t</code></a> first.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-of_uid"><a href="#val-of_uid" class="anchor"></a><code><span><span class="keyword">val</span> of_uid : <span><span><span class="type-var">'fd</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="Blob/index.html#type-t">Blob.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">uid</span>:<a href="Uid/index.html#type-t">Uid.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="Value/index.html#type-t">Value.t</a></span></code></div><div class="spec-doc"><p>As <a href="#val-of_offset"><code>of_offset</code></a>, <code>of_uid pack block ~uid</code> is the object identified by <code>uid</code> into the given <code>pack</code>.</p><p>The given <code>pack</code> must be able to recognize the object's position based on its unique identifier. In other words, <code>pack</code> must be constructed with an exhaustive <code>where</code> function for all the identifiers in the PACK file.</p></div></div><h4 id="path"><a href="#path" class="anchor"></a>Path of object.</h4><p>Due to the fact that <a href="#val-of_offset"><code>of_offset</code></a>/<a href="#val-of_uid"><code>of_uid</code></a> are not <i>tail-rec</i>, an other solution exists to extract an object from the PACK file. However, this solution requires a <i>meta-data</i> <a href="Path/index.html#type-t"><code>Path.t</code></a> to be able to extract an object.</p><p>A <a href="Path/index.html#type-t"><code>Path.t</code></a> is the <i>delta-chain</i> of the object. It assumes that a <i>delta-chain</i> can not be larger than <code>50</code> (see Git assumptions). From it, the way to construct an object is well-know and the step to discover if an object depends on an other one is deleted - and we ensure that the reconstruction is bound over our <a href="Path/index.html#type-t"><code>Path.t</code></a>.</p><div class="odoc-spec"><div class="spec module anchored" id="module-Path"><a href="#module-Path" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Path/index.html">Path</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-path_of_offset"><a href="#val-path_of_offset" class="anchor"></a><code><span><span class="keyword">val</span> path_of_offset : <span><span class="optlabel">?max_depth</span>:int <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'fd</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">cursor</span>:int <span class="arrow">&#45;&gt;</span></span> <a href="Path/index.html#type-t">Path.t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-path_of_uid"><a href="#val-path_of_uid" class="anchor"></a><code><span><span class="keyword">val</span> path_of_uid : <span><span><span class="type-var">'fd</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="Uid/index.html#type-t">Uid.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="Path/index.html#type-t">Path.t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-of_offset_with_path"><a href="#val-of_offset_with_path" class="anchor"></a><code><span><span class="keyword">val</span> of_offset_with_path : 
  <span><span><span class="type-var">'fd</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">path</span>:<a href="Path/index.html#type-t">Path.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="Blob/index.html#type-t">Blob.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">cursor</span>:int <span class="arrow">&#45;&gt;</span></span>
  <a href="Value/index.html#type-t">Value.t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-of_offset_with_source"><a href="#val-of_offset_with_source" class="anchor"></a><code><span><span class="keyword">val</span> of_offset_with_source : <span><span><span class="type-var">'fd</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="Value/index.html#type-t">Value.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">cursor</span>:int <span class="arrow">&#45;&gt;</span></span> <a href="Value/index.html#type-t">Value.t</a></span></code></div><div class="spec-doc"><p><code>of_offset_with_source ~map t ~path source ~cursor</code> is the object available at <code>cursor</code> into <code>t</code>. This function is <i>tail-recursive</i> and use the given <code>source</code> if the requested object is a patch.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-identify"><a href="#type-identify" class="anchor"></a><code><span><span class="keyword">type</span> identify</span><span> = </span></code><ol><li id="type-identify.Identify" class="def variant constructor anchored"><a href="#type-identify.Identify" class="anchor"></a><code><span>| </span><span><span class="constructor">Identify</span> : <span><span class="type-var">'ctx</span> <a href="First_pass/index.html#type-identify">First_pass.identify</a></span> <span class="arrow">&#45;&gt;</span> <a href="#type-identify">identify</a></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Carton can be asked to calculate the identifier of an object but does not require the algorithm used (SHA1 or SHA256 for example) to be known. It only handles the result of this calculation, which is represented by a <a href="Uid/index.html#type-t"><code>Uid.t</code></a>. For more details on how to implement identify, please refer to what is <a href="First_pass/index.html#type-identify" title="First_pass.identify">explained</a> in the first phase of analysing a PACK file. You then simply need to &quot;surround&quot; your value with <code>Carton.Identify</code> to completely abstract the algorithm used to calculate the object identifier.</p><span class="comment-delim">*)</span></div></li></ol></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-uid_of_offset"><a href="#val-uid_of_offset" class="anchor"></a><code><span><span class="keyword">val</span> uid_of_offset : 
  <span><span class="label">identify</span>:<a href="#type-identify">identify</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'fd</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="Blob/index.html#type-t">Blob.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">cursor</span>:int <span class="arrow">&#45;&gt;</span></span>
  <a href="Kind/index.html#type-t">Kind.t</a> * <a href="Uid/index.html#type-t">Uid.t</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-uid_of_offset_with_source"><a href="#val-uid_of_offset_with_source" class="anchor"></a><code><span><span class="keyword">val</span> uid_of_offset_with_source : 
  <span><span class="label">identify</span>:<a href="#type-identify">identify</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'fd</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">kind</span>:<a href="Kind/index.html#type-t">Kind.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="Blob/index.html#type-t">Blob.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">depth</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">cursor</span>:int <span class="arrow">&#45;&gt;</span></span>
  <a href="Uid/index.html#type-t">Uid.t</a></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-children"><a href="#type-children" class="anchor"></a><code><span><span class="keyword">type</span> children</span><span> = <span><span class="label">cursor</span>:int <span class="arrow">&#45;&gt;</span></span> <span><span class="label">uid</span>:<a href="Uid/index.html#type-t">Uid.t</a> <span class="arrow">&#45;&gt;</span></span> <span>int list</span></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-where"><a href="#type-where" class="anchor"></a><code><span><span class="keyword">type</span> where</span><span> = <span><span class="label">cursor</span>:int <span class="arrow">&#45;&gt;</span></span> int</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-oracle"><a href="#type-oracle" class="anchor"></a><code><span><span class="keyword">type</span> oracle</span><span> = </span><span>{</span></code><ol><li id="type-oracle.identify" class="def record field anchored"><a href="#type-oracle.identify" class="anchor"></a><code><span>identify : <a href="#type-identify">identify</a>;</span></code></li><li id="type-oracle.children" class="def record field anchored"><a href="#type-oracle.children" class="anchor"></a><code><span>children : <a href="#type-children">children</a>;</span></code></li><li id="type-oracle.where" class="def record field anchored"><a href="#type-oracle.where" class="anchor"></a><code><span>where : <a href="#type-where">where</a>;</span></code></li><li id="type-oracle.size" class="def record field anchored"><a href="#type-oracle.size" class="anchor"></a><code><span>size : <span><span class="label">cursor</span>:int <span class="arrow">&#45;&gt;</span></span> <a href="Size/index.html#type-t">Size.t</a>;</span></code></li><li id="type-oracle.checksum" class="def record field anchored"><a href="#type-oracle.checksum" class="anchor"></a><code><span>checksum : <span><span class="label">cursor</span>:int <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Optint</span>.t;</span></code></li><li id="type-oracle.is_base" class="def record field anchored"><a href="#type-oracle.is_base" class="anchor"></a><code><span>is_base : <span><span class="label">pos</span>:int <span class="arrow">&#45;&gt;</span></span> <span>int option</span>;</span></code></li><li id="type-oracle.number_of_objects" class="def record field anchored"><a href="#type-oracle.number_of_objects" class="anchor"></a><code><span>number_of_objects : int;</span></code></li><li id="type-oracle.hash" class="def record field anchored"><a href="#type-oracle.hash" class="anchor"></a><code><span>hash : string;</span></code></li></ol><code><span>}</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-status"><a href="#type-status" class="anchor"></a><code><span><span class="keyword">type</span> status</span><span> = </span></code><ol><li id="type-status.Unresolved_base" class="def variant constructor anchored"><a href="#type-status.Unresolved_base" class="anchor"></a><code><span>| </span><span><span class="constructor">Unresolved_base</span> <span class="keyword">of</span> </span><span>{</span></code><ol><li id="type-status.cursor" class="def record field anchored"><a href="#type-status.cursor" class="anchor"></a><code><span>cursor : int;</span></code></li></ol><code><span>}</span></code></li><li id="type-status.Unresolved_node" class="def variant constructor anchored"><a href="#type-status.Unresolved_node" class="anchor"></a><code><span>| </span><span><span class="constructor">Unresolved_node</span></span></code></li><li id="type-status.Resolved_base" class="def variant constructor anchored"><a href="#type-status.Resolved_base" class="anchor"></a><code><span>| </span><span><span class="constructor">Resolved_base</span> <span class="keyword">of</span> </span><span>{</span></code><ol><li id="type-status.cursor" class="def record field anchored"><a href="#type-status.cursor" class="anchor"></a><code><span>cursor : int;</span></code></li><li id="type-status.uid" class="def record field anchored"><a href="#type-status.uid" class="anchor"></a><code><span>uid : <a href="Uid/index.html#type-t">Uid.t</a>;</span></code></li><li id="type-status.crc" class="def record field anchored"><a href="#type-status.crc" class="anchor"></a><code><span>crc : <span class="xref-unresolved">Optint</span>.t;</span></code></li><li id="type-status.kind" class="def record field anchored"><a href="#type-status.kind" class="anchor"></a><code><span>kind : <a href="Kind/index.html#type-t">Kind.t</a>;</span></code></li></ol><code><span>}</span></code></li><li id="type-status.Resolved_node" class="def variant constructor anchored"><a href="#type-status.Resolved_node" class="anchor"></a><code><span>| </span><span><span class="constructor">Resolved_node</span> <span class="keyword">of</span> </span><span>{</span></code><ol><li id="type-status.cursor" class="def record field anchored"><a href="#type-status.cursor" class="anchor"></a><code><span>cursor : int;</span></code></li><li id="type-status.uid" class="def record field anchored"><a href="#type-status.uid" class="anchor"></a><code><span>uid : <a href="Uid/index.html#type-t">Uid.t</a>;</span></code></li><li id="type-status.crc" class="def record field anchored"><a href="#type-status.crc" class="anchor"></a><code><span>crc : <span class="xref-unresolved">Optint</span>.t;</span></code></li><li id="type-status.kind" class="def record field anchored"><a href="#type-status.kind" class="anchor"></a><code><span>kind : <a href="Kind/index.html#type-t">Kind.t</a>;</span></code></li><li id="type-status.depth" class="def record field anchored"><a href="#type-status.depth" class="anchor"></a><code><span>depth : int;</span></code></li><li id="type-status.parent" class="def record field anchored"><a href="#type-status.parent" class="anchor"></a><code><span>parent : <a href="Uid/index.html#type-t">Uid.t</a>;</span></code></li></ol><code><span>}</span></code></li></ol></div></div></div></body></html>
