<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>First_pass (carton.Carton.First_pass)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.4"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">carton</a> &#x00BB; <a href="../index.html">Carton</a> &#x00BB; First_pass</nav><header class="odoc-preamble"><h1>Module <code><span>Carton.First_pass</span></code></h1></header><nav class="odoc-toc"><ul><li><a href="#first-pass-of-a-pack-file.">First-pass of a PACK file.</a><ul><li><a href="#a-delta-object,-an-object-which-requires-a-source.">A delta-object, an object which requires a source.</a></li></ul></li></ul></nav><div class="odoc-content"><h2 id="first-pass-of-a-pack-file."><a href="#first-pass-of-a-pack-file." class="anchor"></a>First-pass of a PACK file.</h2><p>When manipulating a PACK file, it may be necessary to aggregate certain information before extracting objects (such as the size of the buffers that need to be allocated to extract objects). Analysis of the PACK file in the form of a <i>stream</i> is therefore possible and is implemented in this <a href="#"><code>First_pass</code></a> module.</p><p>More concretely, when a user uploads the state of a Git repository (<code>git fetch</code>), a PACK file is transmitted. This analysis can be applied when the PACK file is received (at the same time) and the state can then be saved in the <code>.git</code> folder.</p><pre class="language-ocaml"><code>$ git clone ...
remote: Enumerating objects: 105, done.
remote: Counting objects: 100% (105/105), done.
remote: Compressing objects: 100% (81/81), done.
remote: Total 305 (delta 41), reused 75 (delta 23), pack-reused 200
Receiving objects: 100% (305/305), 100.00 KiB | 0 bytes/s, done. &lt;-- first pass</code></pre><p>The advantage of this module is that it can aggregate information at the same time as receiving the PACK file from the network.</p><div class="odoc-spec"><div class="spec type anchored" id="type-hash"><a href="#type-hash" class="anchor"></a><code><span><span class="keyword">type</span> <span>'ctx hash</span></span><span> = </span><span>{</span></code><ol><li id="type-hash.feed_bytes" class="def record field anchored"><a href="#type-hash.feed_bytes" class="anchor"></a><code><span>feed_bytes : <span>bytes <span class="arrow">&#45;&gt;</span></span> <span><span class="label">off</span>:int <span class="arrow">&#45;&gt;</span></span> <span><span class="label">len</span>:int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'ctx</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'ctx</span>;</span></code></li><li id="type-hash.feed_bigstring" class="def record field anchored"><a href="#type-hash.feed_bigstring" class="anchor"></a><code><span>feed_bigstring : <span><span class="xref-unresolved">De</span>.bigstring <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'ctx</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'ctx</span>;</span></code></li><li id="type-hash.serialize" class="def record field anchored"><a href="#type-hash.serialize" class="anchor"></a><code><span>serialize : <span><span class="type-var">'ctx</span> <span class="arrow">&#45;&gt;</span></span> string;</span></code></li><li id="type-hash.length" class="def record field anchored"><a href="#type-hash.length" class="anchor"></a><code><span>length : int;</span></code></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>A PACK file is always associated with a signature that verifies the integrity of the entire PACK file. As far as Git is concerned, this signature uses the SHA1 hash algorithm. Carton allows another algorithm to be used if required, provided that the user gives it a digest value allowing verification of the integrity of the PACK file segment by segment.</p><pre class="language-ocaml"><code>$ head -c 20 pack-2d9d562730d25620c12799c0bf0d5baf9fd00896.pack|sha1sum
2d9d562730d25620c12799c0bf0d5baf9fd00896  -
$ xxd -p -l 20 -seek -20 pack-2d9d562730d25620c12799c0bf0d5baf9fd00896.pack
2d9d562730d25620c12799c0bf0d5baf9fd00896</code></pre><p>Here's an example of how to propose an algorithm to Carton with Digestif:</p><pre class="language-ocaml"><code>let sha1 =
  let open Digestif.SHA1 in
  let feed bstr ctx = feed_bigstring ctx bstr in
  { feed; serialize= get; length= digest_size }

let sha1 = Digest (sha1, Digestif.SHA1.empty)</code></pre></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-digest"><a href="#type-digest" class="anchor"></a><code><span><span class="keyword">type</span> digest</span><span> = </span></code><ol><li id="type-digest.Digest" class="def variant constructor anchored"><a href="#type-digest.Digest" class="anchor"></a><code><span>| </span><span><span class="constructor">Digest</span> : <span><span class="type-var">'ctx</span> <a href="#type-hash">hash</a></span> * <span class="type-var">'ctx</span> <span class="arrow">&#45;&gt;</span> <a href="#type-digest">digest</a></span></code></li></ol></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-identify"><a href="#type-identify" class="anchor"></a><code><span><span class="keyword">type</span> <span>'ctx identify</span></span><span> = </span><span>{</span></code><ol><li id="type-identify.init" class="def record field anchored"><a href="#type-identify.init" class="anchor"></a><code><span>init : <span><a href="../Kind/index.html#type-t">Kind.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Size/index.html#type-t">Size.t</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'ctx</span>;</span></code></li><li id="type-identify.feed" class="def record field anchored"><a href="#type-identify.feed" class="anchor"></a><code><span>feed : <span><span class="xref-unresolved">De</span>.bigstring <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'ctx</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'ctx</span>;</span></code></li><li id="type-identify.serialize" class="def record field anchored"><a href="#type-identify.serialize" class="anchor"></a><code><span>serialize : <span><span class="type-var">'ctx</span> <span class="arrow">&#45;&gt;</span></span> <a href="../Uid/index.html#type-t">Uid.t</a>;</span></code></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>An object stored in a PACK file can be identified by a unique reference. In the case of Git, this reference is a SHA1 hash resulting from the type, size and content of the object. For the first phase of analysis, it is possible to identify certain objects (more specifically &quot;base&quot; objects).</p><p>Here's an example of how to calculate the identifier of a Git object:</p><pre class="language-ocaml"><code>let identify =
  let open Digestif in
  let kind_to_string = function
    | `A -&gt; &quot;commit&quot;
    | `B -&gt; &quot;tree&quot;
    | `C -&gt; &quot;blob&quot;
    | `D -&gt; &quot;tag&quot;
  in
  let init kind (len : Carton.Size.t) =
    let hdr =
      Format.kasprintf &quot;%s %d\000&quot; (kind_to_string kind) (len :&gt; int)
    in
    let ctx = SHA1.empty in
    SHA1.feed_string ctx hdr
  in
  let feed bstr ctx = SHA1.feed_bigstring ctx bstr in
  let serialize ctx =
    SHA1.get ctx |&gt; SHA1.to_raw_string |&gt; Carton.Uid.unsafe_of_string
  in
  { Carton.First_pass.init; feed; serialize }</code></pre></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-kind"><a href="#type-kind" class="anchor"></a><code><span><span class="keyword">type</span> kind</span><span> = </span></code><ol><li id="type-kind.Base" class="def variant constructor anchored"><a href="#type-kind.Base" class="anchor"></a><code><span>| </span><span><span class="constructor">Base</span> <span class="keyword">of</span> <a href="../Kind/index.html#type-t">Kind.t</a> * <a href="../Uid/index.html#type-t">Uid.t</a></span></code></li><li id="type-kind.Ofs" class="def variant constructor anchored"><a href="#type-kind.Ofs" class="anchor"></a><code><span>| </span><span><span class="constructor">Ofs</span> <span class="keyword">of</span> </span><span>{</span></code><ol><li id="type-kind.sub" class="def record field anchored"><a href="#type-kind.sub" class="anchor"></a><code><span>sub : int;</span></code></li><li id="type-kind.source" class="def record field anchored"><a href="#type-kind.source" class="anchor"></a><code><span>source : <a href="../Size/index.html#type-t">Size.t</a>;</span></code></li><li id="type-kind.target" class="def record field anchored"><a href="#type-kind.target" class="anchor"></a><code><span>target : <a href="../Size/index.html#type-t">Size.t</a>;</span></code></li></ol><code><span>}</span></code></li><li id="type-kind.Ref" class="def variant constructor anchored"><a href="#type-kind.Ref" class="anchor"></a><code><span>| </span><span><span class="constructor">Ref</span> <span class="keyword">of</span> </span><span>{</span></code><ol><li id="type-kind.ptr" class="def record field anchored"><a href="#type-kind.ptr" class="anchor"></a><code><span>ptr : <a href="../Uid/index.html#type-t">Uid.t</a>;</span></code></li><li id="type-kind.source" class="def record field anchored"><a href="#type-kind.source" class="anchor"></a><code><span>source : <a href="../Size/index.html#type-t">Size.t</a>;</span></code></li><li id="type-kind.target" class="def record field anchored"><a href="#type-kind.target" class="anchor"></a><code><span>target : <a href="../Size/index.html#type-t">Size.t</a>;</span></code></li></ol><code><span>}</span></code></li></ol></div><div class="spec-doc"><p>Type of PACK entries.</p><p>Entries in a PACK file can be:</p><ul><li>a compressed object as a base with its type</li><li>an object that can be built using another object (which may ultimately be a base or another object that needs another source)</li></ul><p>For the second category, the source can be found via a cursor (<code>OBJ_OFS_DELTA</code>) or a unique identifier (<code>OBJ_REF_DELTA</code>).</p><p>An <a href="#type-kind.Ofs"><code>Ofs</code></a> type entry is a patch that requires a source to be built. This source is available upstream of the entry, and its position can be calculated using the current position of the entry minus the <code>sub</code> value. The patch gives information about the actual size of the object <code>target</code> and the expected size of the source.</p><p>A <a href="#type-kind.Ref"><code>Ref</code></a> type entry is a patch that also needs a source to build itself. The patch informs you of the actual size of the object <code>target</code> and the size of the expected source. The source can be found thanks to the <code>ptr</code> value given, which corresponds to the unique identifier of the source object (as far as Git is concerned, this identifier corresponds to what <code>git hash-object</code> can give).</p></div></div><h3 id="a-delta-object,-an-object-which-requires-a-source."><a href="#a-delta-object,-an-object-which-requires-a-source." class="anchor"></a>A delta-object, an object which requires a source.</h3><p>As explained <a href="#type-kind" title="kind">above</a>, entries can be a simple compression of the object or a &quot;patch&quot; requiring the source to be an object. The entry in a PACK file can refer to its source using <a href="#type-kind.Ofs" title="Ofs">its position</a> or a unique <a href="#type-kind.Ref" title="Ref">identifier</a>.</p><p>The case where an entry depends on a reference only arises for <i>thin</i> PACK files. These sources are often available elsewhere than in the PACK file. A registered PACK file should <b>not</b> contain references, but it is possible to transmit a PACK file with references to objects existing in other PACK files. One step in recording a PACK file is to <i>canonicalise</i> it: in other words, to ensure that the PACK file is sufficient in itself to extract all the objects.</p><p>The first pass is useful for identifying whether a PACK file is <i>thin</i> or not. Objects are not extracted but identified. It is then up to the user to decide whether or not to canonicalise the PACK file.</p><div class="odoc-spec"><div class="spec type anchored" id="type-entry"><a href="#type-entry" class="anchor"></a><code><span><span class="keyword">type</span> entry</span><span> = </span><span>{</span></code><ol><li id="type-entry.offset" class="def record field anchored"><a href="#type-entry.offset" class="anchor"></a><code><span>offset : int;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Absolute offset into the given PACK file.</p><span class="comment-delim">*)</span></div></li><li id="type-entry.kind" class="def record field anchored"><a href="#type-entry.kind" class="anchor"></a><code><span>kind : <a href="#type-kind">kind</a>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Kind of the object.</p><span class="comment-delim">*)</span></div></li><li id="type-entry.size" class="def record field anchored"><a href="#type-entry.size" class="anchor"></a><code><span>size : <a href="../Size/index.html#type-t">Size.t</a>;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Length of the inflated object.</p><span class="comment-delim">*)</span></div></li><li id="type-entry.consumed" class="def record field anchored"><a href="#type-entry.consumed" class="anchor"></a><code><span>consumed : int;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Length of the deflated object (as it is into the PACK file).</p><span class="comment-delim">*)</span></div></li><li id="type-entry.crc" class="def record field anchored"><a href="#type-entry.crc" class="anchor"></a><code><span>crc : <span class="xref-unresolved">Optint</span>.t;</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Check-sum of the entry (header plus the deflated object).</p><span class="comment-delim">*)</span></div></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>Type of a PACK entries.</p><p><b>Note</b>: The size given by the input is not necessarily the actual size of the object. It is when the object is a <a href="#type-kind.Base"><code>Base</code></a>. However, if the object is a patch (<a href="#type-kind.Ofs"><code>Ofs</code></a> or <a href="#type-kind.Ref"><code>Ref</code></a>), the size of the patch is given. <a href="#type-kind.Ofs"><code>Ofs</code></a> and <a href="#type-kind.Ref"><code>Ref</code></a> give the real size of the object via the <code>target</code> field.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-decoder"><a href="#type-decoder" class="anchor"></a><code><span><span class="keyword">type</span> decoder</span></code></div><div class="spec-doc"><p>The type for decoders.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-src"><a href="#type-src" class="anchor"></a><code><span><span class="keyword">type</span> src</span><span> = </span><span>[ </span></code><ol><li id="type-src.Channel" class="def variant constructor anchored"><a href="#type-src.Channel" class="anchor"></a><code><span>| </span><span>`Channel <span class="keyword">of</span> <span class="xref-unresolved">Stdlib</span>.in_channel</span></code></li><li id="type-src.String" class="def variant constructor anchored"><a href="#type-src.String" class="anchor"></a><code><span>| </span><span>`String <span class="keyword">of</span> string</span></code></li><li id="type-src.Manual" class="def variant constructor anchored"><a href="#type-src.Manual" class="anchor"></a><code><span>| </span><span>`Manual</span></code></li></ol><code><span> ]</span></code></div><div class="spec-doc"><p>The type for input sources. With a <code>`Manual</code> source the client must provide input with <a href="#val-src"><code>src</code></a>.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-decode"><a href="#type-decode" class="anchor"></a><code><span><span class="keyword">type</span> decode</span><span> = </span><span>[ </span></code><ol><li id="type-decode.Await" class="def variant constructor anchored"><a href="#type-decode.Await" class="anchor"></a><code><span>| </span><span>`Await <span class="keyword">of</span> <a href="#type-decoder">decoder</a></span></code></li><li id="type-decode.Peek" class="def variant constructor anchored"><a href="#type-decode.Peek" class="anchor"></a><code><span>| </span><span>`Peek <span class="keyword">of</span> <a href="#type-decoder">decoder</a></span></code></li><li id="type-decode.Entry" class="def variant constructor anchored"><a href="#type-decode.Entry" class="anchor"></a><code><span>| </span><span>`Entry <span class="keyword">of</span> <a href="#type-entry">entry</a> * <a href="#type-decoder">decoder</a></span></code></li><li id="type-decode.End" class="def variant constructor anchored"><a href="#type-decode.End" class="anchor"></a><code><span>| </span><span>`End <span class="keyword">of</span> string</span></code></li><li id="type-decode.Malformed" class="def variant constructor anchored"><a href="#type-decode.Malformed" class="anchor"></a><code><span>| </span><span>`Malformed <span class="keyword">of</span> string</span></code></li></ol><code><span> ]</span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-decoder"><a href="#val-decoder" class="anchor"></a><code><span><span class="keyword">val</span> decoder : 
  <span><span class="label">output</span>:<span class="xref-unresolved">De</span>.bigstring <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">allocate</span>:<span>(<span>int <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">De</span>.window)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">ref_length</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">digest</span>:<a href="#type-digest">digest</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">identify</span>:<span><span class="type-var">'ctx</span> <a href="#type-identify">identify</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-src">src</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-decoder">decoder</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-decode"><a href="#val-decode" class="anchor"></a><code><span><span class="keyword">val</span> decode : <span><a href="#type-decoder">decoder</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-decode">decode</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-number_of_objects"><a href="#val-number_of_objects" class="anchor"></a><code><span><span class="keyword">val</span> number_of_objects : <span><a href="#type-decoder">decoder</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>number_of_objects decoder</code> returns the number of objects available into the PACK file.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-version"><a href="#val-version" class="anchor"></a><code><span><span class="keyword">val</span> version : <span><a href="#type-decoder">decoder</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>version decoder</code> return the version of the PACK file (should be <code>2</code>).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-counter_of_objects"><a href="#val-counter_of_objects" class="anchor"></a><code><span><span class="keyword">val</span> counter_of_objects : <span><a href="#type-decoder">decoder</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>counter_of_objects decoder</code> returns the actual entry processed by the decoder.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-hash"><a href="#val-hash" class="anchor"></a><code><span><span class="keyword">val</span> hash : <span><a href="#type-decoder">decoder</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-digest">digest</a></span></code></div><div class="spec-doc"><p><code>hash decoder</code> returns the actual (and computed by the decoder) signature of the PACK file.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-src_rem"><a href="#val-src_rem" class="anchor"></a><code><span><span class="keyword">val</span> src_rem : <span><a href="#type-decoder">decoder</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>src_rem</code> returns how many byte(s) are not yet processed by the given <code>decoder</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-src"><a href="#val-src" class="anchor"></a><code><span><span class="keyword">val</span> src : <span><a href="#type-decoder">decoder</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">De</span>.bigstring <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <a href="#type-decoder">decoder</a></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-of_seq"><a href="#val-of_seq" class="anchor"></a><code><span><span class="keyword">val</span> of_seq : 
  <span><span class="label">output</span>:<span class="xref-unresolved">De</span>.bigstring <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">allocate</span>:<span>(<span>int <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">De</span>.window)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">ref_length</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">digest</span>:<a href="#type-digest">digest</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">identify</span>:<span><span class="type-var">'ctx</span> <a href="#type-identify">identify</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>string <span class="xref-unresolved">Stdlib</span>.Seq.t</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>[ <span>`Number of int</span> <span><span>| `Entry</span> of <a href="#type-entry">entry</a></span> <span><span>| `Hash</span> of string</span> ]</span> <span class="xref-unresolved">Stdlib</span>.Seq.t</span></span></code></div><div class="spec-doc"><p><code>of_seq ~output ~allocate ~ref_length ~digest seq</code> analyses a PACK stream given by <code>seq</code> and returns a stream of all the entries in the given PACK stream as well as the final signature of the PACK stream. Several values are expected:</p><ul><li><code>output</code> is a temporary buffer used to decompress the inputs</li><li><code>allocate</code> is a function used to allocate a window needed for decompression</li><li><code>ref_length</code> is the size (in bytes) of the unique identifier of an object (for Git, this size is <code>20</code>, the size of a SHA1 hash)</li><li><code>digest</code> is the algorithm used to check the integrity of the stream PACK (for Git, the algorithm is SHA1, see <a href="#type-hash"><code>hash</code></a>)</li></ul></div></div></div></body></html>
